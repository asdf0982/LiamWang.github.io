<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UEditor的数据回显]]></title>
    <url>%2F2017%2F05%2F26%2FUEditor%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[最近遇到了ueditor的不能显示数据的回显问题。解决思路： 在jsp页面添加hidden类型的input栏，作为中转站保存数据。 使用js代码配置ueditor面板，从上获得数据并展示 12&lt;input id="temp" type="hidden" value="$&#123;***.**&#125;"&gt;&lt;srcipt id="container" name="content" type="text/plain"&gt;&lt;/srcipt&gt; 12345&lt;script type="text/javascript"&gt;var ue = UE.getEditor('container');ue.ready(function()&#123;ue.setContent($('#temp').val());&#125;);]]></content>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接电脑时蓝牙耳机音质明显下降]]></title>
    <url>%2F2017%2F05%2F25%2F%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E6%97%B6%E8%93%9D%E7%89%99%E8%80%B3%E6%9C%BA%E9%9F%B3%E8%B4%A8%E6%98%8E%E6%98%BE%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[先比较连接手机时的音质，判断是否为耳机自身故障。 确定非耳机故障时，右击【蓝牙设备】图标-【显示蓝牙设备】 在相关设置下选择【设备和打印机】 右击【蓝牙耳机】图标-声音设置 观察到一个耳机却又两个模式，点开Stereo模式的【属性】-选择【高级】 观察到“2通道，CD音质”说明现在使用的耳机模式是听音乐的。 作为对比回去再打开Hands-Free模式的【属性】【高级】 观察到“1通道，电话音质”，这就是我之前使用的，音质明显下降的版本。 选择Stereo为默认模式。]]></content>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231n 学习笔记(SVM)]]></title>
    <url>%2F2017%2F05%2F24%2FCS231n-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SVM%2F</url>
    <content type="text"><![CDATA[hstack(),vstack()12345678910111213141516171819202122import numpy as npx = np.array([[1,2],[3,4],[5,6]])a = np.ones((x.shape[0],1))b = np.ones((1,x.shape[1]))c = np.hstack([x,a])d = np.vstack([x,b])print (a)print (b)print (c)print (d)[[ 1.] [ 1.] [ 1.]][[ 1. 1.]][[ 1. 2. 1.] [ 3. 4. 1.] [ 5. 6. 1.]][[ 1. 2.] [ 3. 4.] [ 5. 6.] [ 1. 1.]] h-horizontalv-vertical难以表达自行感受 numpy.random.randn(d0, d1, …, dn)其中d0, d1, …, dn为整数型，输出标准正太分布的矩阵。若想输出$N(\mu,\sigma^2)$则公式为：$\sigma$*np.random.randn(…)+$\mu$若我们要生成满足正太分布为N(3，2.5^2)，2行4列的数组，则2.5*np.random.randn(2, 4)+3输出12array([[-4.49401501, 4.00950034, -1.81814867, 7.29718677], [ 0.39924804, 4.68456316, 4.99394529, 4.84057254]]) svm_loss_naive()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def svm_loss_naive(W, X, y, reg): """ Structured SVM loss function, naive implementation (with loops). Inputs have dimension D, there are C classes, and we operate on minibatches of N examples. Inputs: - W: A numpy array of shape (D, C) containing weights. - X: A numpy array of shape (N, D) containing a minibatch of data. - y: A numpy array of shape (N,) containing training labels; y[i] = c means that X[i] has label c, where 0 &lt;= c &lt; C. - reg: (float) regularization strength Returns a tuple of: - loss as single float - gradient with respect to weights W; an array of same shape as W """ dW = np.zeros(W.shape) # initialize the gradient as zero # compute the loss and the gradient num_classes = W.shape[1] num_train = X.shape[0] loss = 0.0 for i in xrange(num_train): scores = X[i].dot(W) #scores包含10个类别的分数 correct_class_score = scores[y[i]] #正确类别下的分数 for j in xrange(num_classes): if j == y[i]: continue margin = scores[j] - correct_class_score + 1 # note delta = 1 if margin &gt; 0: loss += margin dW[:,y[i]] += X[i,:] dW[:,j] += -X[i,:] # Right now the loss is a sum over all training examples, but we want it # to be an average instead so we divide by num_train. loss /= num_train dW /= num_train # Add regularization to the loss. loss += 0.5 * reg * np.sum(W * W) dW += reg * W return loss, dW dW部分参考：梯度推导]]></content>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231n学习笔记]]></title>
    <url>%2F2017%2F05%2F22%2FCS231n%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[完成作业: [k_nearest_neighbor.py] [knn.ipynb] enumerate()12for y, cls in enumerate(classes): print y, cls enumerate能遍历一个数组或列表，并获得索引和索引内容。得到：123456789100 plane1 car2 bird3 cat4 deer5 dog6 frog7 horse8 ship9 truck flatnonzero()12idxs = np.flatnonzero(y_train == y)print idxs y_train 为训练集图片的标签集。flatnonzero() 打印非零元素的位置。整体意为以图片标签分类，输出图片的下标。12345678910[ 29 30 35 ..., 49941 49992 49994][ 4 5 32 ..., 49993 49998 49999][ 6 13 18 ..., 49987 49991 49995][ 9 17 21 ..., 49979 49982 49983][ 3 10 20 ..., 49981 49984 49990][ 27 40 51 ..., 49964 49980 49988][ 0 19 22 ..., 49962 49966 49996][ 7 11 12 ..., 49965 49978 49986][ 8 62 69 ..., 49968 49976 49985][ 1 2 14 ..., 49963 49971 49997] np.random.choice()官方介绍12idxs = np.random.choice(idxs, samples_per_class, replace=False) print idxs 从idxs中随机取出samples_per_class个数，不可重复。 subplot(m,n,p)1plt.subplot(samples_per_class, num_classes, plt_idx) subplot(m,n,p)是将多个图画到一个平面上的工具。其中，m表示是图排成m行，n表示图排成n列，也就是整个figure中有n个图是排成一行的，一共m行，如果m=2就是表示2行图。p表示图所在的位置，p=1表示从左到右从上到下的第一个位置。 reshape()1X_train = np.reshape(X_train, (X_train.shape[0], -1)) 如果newshape给的参数是（x,-1）,那么函数会自动判别newshape为(x, mn/x）,这里的x一定要能被m*n整除！stackoverflow有相关的介绍。‘-1’在此处的意义-1表示我懒得计算该填什么数字，让机器通过其他的值推测出来。 k_nearest_neighbor.py 作业12345678910111213for i in xrange(num_test): for j in xrange(num_train): ##################################################################### # TODO: # # Compute the l2 distance between the ith test point and the jth # # training point, and store the result in dists[i, j]. You should # # not use a loop over dimension. # ##################################################################### dists[i,j] = np.sum((X[i,:]-self.X_train[j,:])**2) ##################################################################### # END OF YOUR CODE # ##################################################################### return dists 这里代表X为测试集，X_train是训练集。X有500个点，每个点代表一张图片，有32*32维。每个点的维度都与训练集X_train相减后求平方的和。得到测试集与训练集的点的“距离”。 Inline Question #1: Notice the structured patterns in the distance matrix, where some rows or columns are visible brighter. (Note that with the default color scheme black indicates low distances while white indicates high distances.) What in the data is the cause behind the distinctly bright rows? What causes the columns?Your Answer: 明亮的行表示当前测试图与多数训练图相似度低，明亮的列表示当前训练图与多数测试图相似度低 argsort()返回的是数组值从小到大的索引值123x = np.array([3, 1, 2])np.argsort(x)array([1, 2, 0]) most_common()获取出现频率最高的s个字符1234567from collections import Counters = '''A Counter is a dict subclass for counting hashable objects. It is an unordered collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The Counter class is similar to bags or multisets in other languages.'''.lower()c = Counter(s)# 获取出现频率最高的5个字符print c.most_common(5)# Result:[(' ', 54), ('e', 32), ('s', 25), ('a', 24), ('t', 24)] numpy.linalg.norm(x, ord=None, axis=None, keepdims=False)官方解释ord表示求哪种范数，默认为L2范数。axis表示按照什么维度。0就是x轴，（0就是竖着比较，1就是横着比较。）具体看下面例子。12345678&gt;&gt;&gt; c = np.array([[ 1, 2, 3],... [-1, 1, 4]])&gt;&gt;&gt; LA.norm(c, axis=0)array([ 1.41421356, 2.23606798, 5. ])&gt;&gt;&gt; LA.norm(c, axis=1)array([ 3.74165739, 4.24264069])&gt;&gt;&gt; LA.norm(c, ord=1, axis=1)array([ 6., 6.]) numpy.ndarray.T矩阵的转置1234567&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])&gt;&gt;&gt; xarray([[ 1., 2.], [ 3., 4.]])&gt;&gt;&gt; x.Tarray([[ 1., 3.], [ 2., 4.]]) 作业 no-loops部分1234M = np.dot(X, self.X_train.T)te = np.square(X).sum(axis = 1)tr = np.square(self.X_train).sum(axis = 1)dists = np.sqrt(-2*M+tr+np.matrix(te).T) 利用(a-b)^2=a^2+b^2-2ab和numpy的broadcasting性质。]]></content>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm架构下json数据传递问题和解决]]></title>
    <url>%2F2017%2F05%2F18%2Fssm%E6%9E%B6%E6%9E%84%E4%B8%8Bjson%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[环境说明 springmvc-4.3.6 jar包 jackson-2.7.4 [jar]包 代码说明在springmvc.xml文件中采用&lt;mvc:annotation-driven/&gt;注解驱动。在jsp文件下,配置一个按钮调用下面的js代码12345678910function requestJson()&#123; $ajax(&#123; type:"post", url:"$&#123;pageContext.request.contextPath &#125;/requestJson.action", data:'&#123;"articleid":10,"title":"test"&#125;', success:function(data)&#123; alert(data); &#125; &#125;);&#125; 在后台创建一个controller。传入json数据，@RequestBody转为实体类。传出实体类，使用@ResponseBody转为json格式。1234567@Controllerpublic class JsonTest&#123; @RequestMapping("/requestJson") public @ResponseBody items requestJson(@RequestBody Items items)&#123; return items; &#125;&#125; 在浏览器中打开jsp页面，F12控制台观察requestJson.action的状态码 问题1.状态码200/415，不进入后端controller断点，浏览器弹出网页html代码解决办法：缺少class，更换jar包。 2.状态码400/500，不进入后端controller断点，浏览器无反应解决办法：jsp页面中data数据需采用正确的json编写格式，以逗号分隔。]]></content>
      <tags>
        <tag>spring mvc</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下使用hexo+github部署个人博客]]></title>
    <url>%2F2017%2F05%2F17%2F20170517%2F</url>
    <content type="text"><![CDATA[需要装好git, node.js 并全程科学上网(全局代理)。 使用gitbash npm install hexo 新建文件夹用于个人博客，并进入目录下hexo init 继续使用hexo g 和hexo s 生成并本地测试网站, 打开浏览器输入localhost:4000 ，此时需临时关闭全局代理方可看到本地博客。 配置config.yml文件(关键为deploy区域，其余部分自由发挥) 1234deploy: type: git repo: https://github.com/asdf0982/asdf0982.github.io.git branch: master 使用hexo d 将本地文档上传到github(需全局代理保证网络链接)如一切正常会弹出一个github登录框。关于ssh的配置，其实只是省略了这个登录的步骤。]]></content>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>windows</tag>
      </tags>
  </entry>
</search>